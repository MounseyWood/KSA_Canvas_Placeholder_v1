<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Text Camouflage</title>
    <!-- Import p5.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #p5-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff200;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }
        
        .word {
            display: inline-block;
            margin-right: 5px;
            cursor: pointer;
            transition: color 0.2s, font-weight 0.2s;
        }
    </style>
</head>
<body>
    <div id="p5-canvas"></div>
    <div class="loading" id="loading-message">Loading words from CSV...</div>
    
    <script>
        // Default words to use if CSV loading fails
        const defaultWords = [
            "Fashion", "Style", "Design", "Trend", "Collection", "Luxury", "Vogue", "Apparel", 
            "Couture", "Runway", "Ensemble", "Editorial", "Silhouette", "Bespoke", "Elegance", 
            "Fabric", "Textile", "Pattern", "Garment", "Accessory", "Tailor", "Aesthetic", 
            "Iconic", "Chic", "Sophisticated", "Contemporary", "Minimal", "Maximalist", 
            "Vintage", "Retro", "Sustainable", "Artisanal", "Avant-garde", "Eclectic", 
            "Timeless", "Season", "Palette", "Denim", "Leather", "Cotton", "Silk", "Wool"
        ];
        
        // Main p5.js sketch
        new p5(function(p) {
            let words = [];
            let textElements = [];
            let wordObjects = [];
            let csvLoaded = false;
            let loadingFailed = false;
            
            // Text object constructor for interactive text
            class TextObject {
                constructor(text, x, y, weight) {
                    this.text = text;
                    this.x = x;
                    this.y = y;
                    this.weight = weight;
                    this.color = p.color(0, 0, 0); // Black
                    this.targetColor = p.color(0, 0, 0);
                    this.colorTransition = 0;
                    this.active = false;
                }
                
                display() {
                    if (this.colorTransition < 1) {
                        this.color = p.lerpColor(this.color, this.targetColor, 0.1);
                        this.colorTransition += 0.1;
                    }
                    
                    p.fill(this.color);
                    p.textStyle(this.weight);
                    p.text(this.text, this.x, this.y);
                }
                
                setHover(isHovered) {
                    if (isHovered) {
                        this.targetColor = p.color(255, 255, 255); // White
                    } else {
                        this.targetColor = p.color(0, 0, 0); // Black
                    }
                    this.colorTransition = 0;
                }
                
                isNear(x, y, radius) {
                    const distance = p.dist(this.x, this.y, x, y);
                    return distance < radius;
                }
                
                updateWeight(distance, maxDistance) {
                    if (distance < maxDistance) {
                        const intensity = 1 - distance / maxDistance;
                        this.weight = p.NORMAL + Math.floor(intensity * 2); // Range from NORMAL to BOLD
                    } else {
                        this.weight = p.NORMAL;
                    }
                }
            }
            
            p.preload = function() {
                // Try to load CSV file
                try {
                    p.loadTable('words.csv', 'csv', 'header', 
                        // Success callback
                        function(table) {
                            document.getElementById('loading-message').textContent = "Processing words...";
                            
                            // Extract words from the table
                            if (table.getRowCount() > 0) {
                                for (let r = 0; r < table.getRowCount(); r++) {
                                    // Try different column names or get first column
                                    let word = table.getString(r, 'word') || 
                                              table.getString(r, 'Word') || 
                                              table.getString(r, table.columns[0]);
                                              
                                    if (word && word.trim() !== '') {
                                        words.push(word.trim());
                                    }
                                }
                            }
                            
                            // If no words were extracted, use defaults
                            if (words.length === 0) {
                                console.warn("CSV file was loaded but no words were found. Using defaults.");
                                words = defaultWords;
                            }
                            
                            csvLoaded = true;
                            console.log(`Successfully loaded ${words.length} words from CSV`);
                        },
                        // Error callback
                        function(error) {
                            console.error("Error loading CSV:", error);
                            words = defaultWords;
                            loadingFailed = true;
                            csvLoaded = true;
                        }
                    );
                } catch (e) {
                    console.error("Exception during CSV loading:", e);
                    words = defaultWords;
                    loadingFailed = true;
                    csvLoaded = true;
                }
            };
            
            p.setup = function() {
                // Create canvas that fills the window
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('p5-canvas');
                
                p.textFont('Arial');
                p.textSize(16);
                p.textAlign(p.LEFT, p.TOP);
                
                // If CSV loading failed or succeeded, initialize
                if (csvLoaded) {
                    initializeWords();
                } else {
                    // Set a timeout in case CSV loading is taking too long
                    setTimeout(function() {
                        if (!csvLoaded) {
                            console.warn("CSV loading timeout - using default words");
                            words = defaultWords;
                            loadingFailed = true;
                            csvLoaded = true;
                            initializeWords();
                        }
                    }, 5000); // 5 second timeout
                }
            };
            
            p.draw = function() {
                // Set background to yellow (#fff200)
                p.background(255, 242, 0);
                
                // If CSV is still loading, display loading message
                if (!csvLoaded) {
                    return;
                }
                
                // Remove loading message once words are ready
                if (document.getElementById('loading-message')) {
                    document.getElementById('loading-message').style.display = 'none';
                }
                
                // Display all word objects
                for (let i = 0; i < wordObjects.length; i++) {
                    wordObjects[i].display();
                    
                    // Update word weight based on mouse proximity
                    const distance = p.dist(wordObjects[i].x, wordObjects[i].y, p.mouseX, p.mouseY);
                    wordObjects[i].updateWeight(distance, 100);
                }
            };
            
            // Initialize text layout with words
            function initializeWords() {
                // Fallback if needed
                if (!words || words.length === 0) {
                    words = defaultWords;
                }
                
                // Clear any existing word objects
                wordObjects = [];
                
                // Calculate roughly how many words to use based on screen size
                const density = 0.001; // words per pixel
                const targetCount = Math.ceil(p.width * p.height * density);
                
                // Create word objects with random positions
                let x = 10;
                let y = 20;
                const lineHeight = 24;
                const margin = 5;
                
                // Randomize the word weights
                const weights = [p.NORMAL, p.BOLD];
                
                for (let i = 0; i < targetCount; i++) {
                    // Get a random word
                    const word = words[Math.floor(p.random(words.length))];
                    const weight = weights[Math.floor(p.random(weights.length))];
                    
                    // Calculate width of this word
                    p.textStyle(weight);
                    const wordWidth = p.textWidth(word) + margin;
                    
                    // If we're going to exceed the canvas width, move to next line
                    if (x + wordWidth > p.width - 10) {
                        x = 10;
                        y += lineHeight;
                    }
                    
                    // If we're going to exceed the canvas height, start over from top
                    if (y > p.height - lineHeight) {
                        break; // We've filled the screen
                    }
                    
                    // Create the word object
                    let textObj = new TextObject(word, x, y, weight);
                    wordObjects.push(textObj);
                    
                    // Move position for next word
                    x += wordWidth;
                }
            }
            
            // Ripple effect when clicking
            p.mousePressed = function() {
                // Create multiple ripples
                for (let i = 0; i < 5; i++) {
                    setTimeout(function() {
                        const radius = 50 + i * 20;
                        const affectedWords = wordObjects.filter(word => 
                            word.isNear(p.mouseX, p.mouseY, radius) && p.random() < 0.3);
                            
                        affectedWords.forEach(word => {
                            word.setHover(true);
                            setTimeout(() => word.setHover(false), 200 + p.random() * 800);
                        });
                    }, i * 100);
                }
            };
            
            // Hover effect
            p.mouseMoved = function() {
                for (let i = 0; i < wordObjects.length; i++) {
                    if (wordObjects[i].isNear(p.mouseX, p.mouseY, 30) && p.random() < 0.3) {
                        wordObjects[i].setHover(true);
                        setTimeout(() => wordObjects[i].setHover(false), 500 + p.random() * 1000);
                    }
                }
            };
            
            // Resize canvas when window is resized
            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                initializeWords();
            };
            
        }, 'p5-canvas');
    </script>
</body>
</html>
