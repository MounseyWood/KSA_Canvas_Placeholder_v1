<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Variable-Width Grid with Hover Expansions</title>
  <!-- p5.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <script>
    // We'll load the CSV of words in preload()
    let wordTable;
    // Array to hold all words from the CSV
    let words = [];

    // Each word becomes a "cell" object in an array:
    // {
    //   index: number,
    //   word: string,
    //   x: number,
    //   y: number,
    //   w: number, // current measured width (depends on global scale)
    //   h: number, // current measured height
    //   localMult: number, // adjacency expansion
    //   jostleSeedX: number, // for noise-based jostling
    //   jostleSeedY: number
    // }
    let cells = [];

    // Global scale factor (adjustable with scroll wheel)
    let globalScale = 1;

    // Day (0) or Night (1)
    let mode = 0;

    // Noise parameters for coloring
    let noiseScale = 0.03;
    let t = 0;

    // Slight jostle motion
    let jostleSpeed = 0.01; // speed of noise over time
    let jostleAmp = 3;      // how many pixels to move

    // Adjacency expansions by index distance
    // e.g. if distance = 0 => 3.0, distance = 1 => 2.0, etc.
    let expansionMap = [3.0, 2.0, 1.5, 1.25];

    // Load the CSV in preload (so it's ready before setup())
    function preload() {
      // CSV must be in the same folder as index.html
      // with a header column named "word"
      wordTable = loadTable('words.csv', 'csv', 'header');
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      noStroke();
      textAlign(LEFT, TOP);

      // Pull words from the CSV
      for (let i = 0; i < wordTable.getRowCount(); i++) {
        words.push(wordTable.getString(i, 'word'));
      }

      // Initialize the cells array
      for (let i = 0; i < words.length; i++) {
        cells.push({
          index: i,
          word: words[i],
          x: 0,
          y: 0,
          w: 0,
          h: 0,
          localMult: 1,
          jostleSeedX: random(1000),
          jostleSeedY: random(1000),
        });
      }
    }

    function draw() {
      // Background depends on day/night
      if (mode === 0) {
        // Day
        background(255);
      } else {
        // Night
        background(0);
      }

      // We'll recalc the layout every frame, so we can adapt to zoom changes
      layoutCells();

      // Find which cell (if any) is under the mouse
      let hoverIndex = findHoveredCell();

      // Assign localMult based on adjacency in index space
      assignLocalMultipliers(hoverIndex);

      // Sort cells so that the biggest (hovered) is drawn last => on top
      cells.sort((a, b) => a.localMult - b.localMult);

      // Draw the cells
      for (let c of cells) {
        drawCell(c);
      }

      // Increment time for the color noise animation
      t += 0.005;
    }

    // Lays out the cells in rows of variable widths
    function layoutCells() {
      // We'll set textSize each frame based on globalScale
      textSize(12 * globalScale);

      let xPos = 10;    // left margin
      let yPos = 10;    // top margin
      let rowHeight = 0;

      for (let c of cells) {
        // Measure the text at the current scale
        let tw = textWidth(c.word);
        // Add some padding
        let th = textAscent() + textDescent() + 6 * globalScale;
        let cellW = tw + 10 * globalScale;
        let cellH = th;

        // If we exceed the canvas width, move to the next row
        if (xPos + cellW > width - 10) {
          xPos = 10;
          yPos += rowHeight + 5; // small vertical gap
          rowHeight = 0;
        }

        c.x = xPos;
        c.y = yPos;
        c.w = cellW;
        c.h = cellH;

        xPos += cellW;
        // Keep track of the tallest cell in this row
        if (cellH > rowHeight) {
          rowHeight = cellH;
        }
      }
    }

    // Returns the index of the cell under the mouse, or -1 if none
    function findHoveredCell() {
      // We'll check bounding boxes for each cell, ignoring expansions for simplicity
      // (so you can more easily hover a cell even if itâ€™s behind expansions).
      // If you want to consider expansions, you'd have to measure them after localMult is assigned.
      for (let i = cells.length - 1; i >= 0; i--) {
        // Check from topmost forward so we find the "front" cell first
        let c = cells[i];
        let xJ = jostleX(c);
        let yJ = jostleY(c);
        let left = c.x + xJ;
        let right = left + c.w;
        let top = c.y + yJ;
        let bottom = top + c.h;
        if (mouseX >= left && mouseX <= right && mouseY >= top && mouseY <= bottom) {
          return c.index;
        }
      }
      return -1;
    }

    // Assign local scale multipliers based on adjacency in index space
    function assignLocalMultipliers(hoverIndex) {
      if (hoverIndex < 0) {
        // No cell hovered
        for (let c of cells) {
          c.localMult = 1;
        }
        return;
      }

      for (let c of cells) {
        let d = abs(c.index - hoverIndex);
        if (d < expansionMap.length) {
          c.localMult = expansionMap[d];
        } else {
          c.localMult = 1;
        }
      }
    }

    // Draw one cell, using noise-based color and expansions
    function drawCell(c) {
      push();

      // Slight jostle motion
      let xOffset = jostleX(c);
      let yOffset = jostleY(c);

      // Translate to cell origin, then apply local + global scale
      // We already accounted for global scale in measuring c.w, c.h,
      // but the adjacency expansions are extra
      translate(c.x + xOffset, c.y + yOffset);

      // For color, we use the cell's top-left as a noise input
      // (plus time) so it animates
      let n = noise((c.x) * noiseScale, (c.y) * noiseScale, t);

      // If Day mode:
      if (mode === 0) {
        // 0.0 to 0.33 => black background, yellow text
        // 0.33 to 0.66 => yellow background, black text
        // 0.66 to 1.0 => white background, black text
        if (n < 0.33) {
          fill(0); // black
          rect(0, 0, c.w * c.localMult, c.h * c.localMult);
          fill(255, 237, 0); // yellow text
        } else if (n < 0.66) {
          fill(255, 237, 0); // yellow
          rect(0, 0, c.w * c.localMult, c.h * c.localMult);
          fill(0); // black text
        } else {
          fill(255); // white
          rect(0, 0, c.w * c.localMult, c.h * c.localMult);
          fill(0); // black text
        }
      } 
      // If Night mode:
      else {
        // 0.0 to 0.33 => white background, blue text
        // 0.33 to 0.66 => blue background, white text
        // 0.66 to 1.0 => black background, white text
        // using rgb(0,146,212) as requested
        if (n < 0.33) {
          fill(255); // white
          rect(0, 0, c.w * c.localMult, c.h * c.localMult);
          fill(0, 146, 212); // blue text
        } else if (n < 0.66) {
          fill(0, 146, 212); // blue
          rect(0, 0, c.w * c.localMult, c.h * c.localMult);
          fill(255); // white text
        } else {
          fill(0); // black
          rect(0, 0, c.w * c.localMult, c.h * c.localMult);
          fill(255); // white text
        }
      }

      // If it's the hovered cell, draw bold
      if (c.localMult >= 3) {
        textStyle(BOLD);
      } else {
        textStyle(NORMAL);
      }

      // Draw the text
      // We'll apply the adjacency expansion to the text as well
      scale(c.localMult);
      textSize(12 * globalScale);
      text(c.word, 5, 3);

      pop();
    }

    // Return small x/y offsets for the jostle effect
    function jostleX(c) {
      return (noise(c.jostleSeedX + frameCount * jostleSpeed) - 0.5) * jostleAmp;
    }
    function jostleY(c) {
      return (noise(c.jostleSeedY + frameCount * jostleSpeed) - 0.5) * jostleAmp;
    }

    // Toggle day/night on mouse click
    function mousePressed() {
      mode = (mode + 1) % 2;
    }

    // Mouse wheel => zoom in/out
    function mouseWheel(event) {
      globalScale = constrain(globalScale - event.delta * 0.001, 0.5, 5);
      return false; // prevent default scroll
    }

    // Keep canvas full screen
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
