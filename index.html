<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Text Camouflage</title>
    <!-- Import p5.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #p5-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff200;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="p5-canvas"></div>
    <div class="loading" id="loading-message">Loading words from CSV...</div>
    
    <script>
        // Default words to use if CSV loading fails
        const defaultWords = [
            "Prada", "Gucci", "YSL", "Dior", "Phoebe Philo", "Roland Mouret", 
            "Paul Smith", "Dunhill", "Vivienne Westwood", "Jigsaw", "Toast", 
            "H&M", "Hugo Boss", "ZARA", "Tommy Hilfiger", "Timberland", 
            "Lululemon", "Adidas", "Nike", "Gymshark", "Reiss", "Kestin", 
            "Oliver Spencer", "Dries van Noten", "Martin Margiela", "Donna Karan",
            "Ralph Lauren", "Calvin Klein", "Armani", "Lacoste", "All Saints", 
            "COS", "ASOS"
        ];
        
        // Main p5.js sketch
        new p5(function(p) {
            // Array to store words loaded from CSV
            let words = [];
            let csvLoaded = false;
            
            // Size of each text "cell"
            let cellW = 80;
            let cellH = 18;
            
            // Noise settings
            let noiseScale = 0.03;
            let t = 0; // time variable to animate the noise
            
            // Interactive elements
            let mouseInteractionRadius = 100;
            let interactiveWords = [];
            let hoveredCells = [];
            
            // Cell tracking for interactivity
            class Cell {
                constructor(x, y, w, h, word, colorScheme) {
                    this.x = x;
                    this.y = y;
                    this.w = w;
                    this.h = h;
                    this.word = word;
                    this.colorScheme = colorScheme;
                    this.hovered = false;
                    this.hoverTime = 0;
                }
                
                contains(px, py) {
                    return (px >= this.x && px <= this.x + this.w && 
                            py >= this.y && py <= this.y + this.h);
                }
                
                isNear(px, py, radius) {
                    let cx = this.x + this.w/2;
                    let cy = this.y + this.h/2;
                    let distance = p.dist(px, py, cx, cy);
                    return distance < radius;
                }
            }
            
            p.preload = function() {
                // Try to load CSV file
                try {
                    p.loadTable('words.csv', 'csv', 'header', 
                        // Success callback
                        function(table) {
                            document.getElementById('loading-message').textContent = "Processing words...";
                            
                            // Extract words from the table
                            if (table.getRowCount() > 0) {
                                for (let r = 0; r < table.getRowCount(); r++) {
                                    // Try different column names or get first column
                                    let word = table.getString(r, 'word') || 
                                              table.getString(r, 'Word') || 
                                              table.getString(r, table.columns[0]);
                                              
                                    if (word && word.trim() !== '') {
                                        words.push(word.trim());
                                    }
                                }
                            }
                            
                            // If no words were extracted, use defaults
                            if (words.length === 0) {
                                console.warn("CSV file was loaded but no words were found. Using defaults.");
                                words = [...defaultWords];
                            }
                            
                            csvLoaded = true;
                            console.log(`Successfully loaded ${words.length} words from CSV`);
                        },
                        // Error callback
                        function(error) {
                            console.error("Error loading CSV:", error);
                            words = [...defaultWords];
                            csvLoaded = true;
                        }
                    );
                } catch (e) {
                    console.error("Exception during CSV loading:", e);
                    words = [...defaultWords];
                    csvLoaded = true;
                }
            };
            
            p.setup = function() {
                // Create canvas that fills the window
                let canvas = p.createCanvas(p.windowWidth, p.windowHeight);
                canvas.parent('p5-canvas');
                
                p.textSize(12);
                p.textAlign(p.LEFT, p.TOP);
                p.noStroke();
                
                // Adjust cell size based on screen dimensions
                cellW = p.min(80, p.windowWidth / 10);
                cellH = 18;
                
                // If CSV loading timed out, use defaults
                setTimeout(function() {
                    if (!csvLoaded) {
                        console.warn("CSV loading timeout - using default words");
                        words = [...defaultWords];
                        csvLoaded = true;
                    }
                }, 5000); // 5 second timeout
            };
            
            p.draw = function() {
                // If CSV is still loading, wait
                if (!csvLoaded) {
                    return;
                }
                
                // Remove loading message once words are ready
                if (document.getElementById('loading-message')) {
                    document.getElementById('loading-message').style.display = 'none';
                }
                
                // Ensure we have words to use
                if (!words || words.length === 0) {
                    words = [...defaultWords];
                }
                
                // Reset cells array each frame
                interactiveWords = [];
                
                // We'll fill the canvas with text blocks in a wiggly grid
                let wordIndex = 0;
                
                for (let y = 0; y < p.height; y += cellH) {
                    for (let x = 0; x < p.width; x += cellW) {
                        // 1) Calculate wiggly offsets to move each cell from its grid position
                        let offsetX = p.map(p.noise(x * noiseScale, y * noiseScale, t), 0, 1, -cellW/2, cellW/2);
                        let offsetY = p.map(p.noise(x * noiseScale + 999, y * noiseScale + 999, t), 0, 1, -cellH/2, cellH/2);
                        let finalX = x + offsetX;
                        let finalY = y + offsetY;
                        
                        // 2) Use another noise value to decide the cell's "blocky" color pattern
                        let n = p.noise(x * noiseScale + 555, y * noiseScale + 555, t);
                        let colorScheme = 0;
                        
                        if (n < 0.33) {
                            p.fill(0);                  // black background
                            p.rect(finalX, finalY, cellW, cellH);
                            p.fill('#fff200');          // yellow text
                            colorScheme = 1;
                        } else if (n < 0.66) {
                            p.fill('#fff200');          // yellow background
                            p.rect(finalX, finalY, cellW, cellH);
                            p.fill(0);                  // black text
                            colorScheme = 2;
                        } else {
                            p.fill(255);                // white background
                            p.rect(finalX, finalY, cellW, cellH);
                            p.fill(0);                  // black text
                            colorScheme = 3;
                        }
                        
                        // Get the word to display
                        let word = words[wordIndex % words.length];
                        wordIndex++;
                        
                        // 3) Draw the text inside this cell
                        p.text(word, finalX + 2, finalY + 2);
                        
                        // 4) Create an interactive cell for this word
                        interactiveWords.push(new Cell(finalX, finalY, cellW, cellH, word, colorScheme));
                    }
                }
                
                // Check for hover effects
                processHoverEffects();
                
                // Draw hover effects on top
                drawHoverEffects();
                
                // 5) Increment time at a slower rate for gentler animation
                t += 0.003;
            };
            
            function processHoverEffects() {
                // Find cells near the mouse
                for (let i = 0; i < interactiveWords.length; i++) {
                    let cell = interactiveWords[i];
                    
                    // Check if mouse is near this cell
                    if (cell.isNear(p.mouseX, p.mouseY, mouseInteractionRadius)) {
                        // Random chance to highlight on hover to create organic effect
                        if (p.random() < 0.05 && !cell.hovered) {
                            cell.hovered = true;
                            cell.hoverTime = 0;
                            hoveredCells.push(cell);
                        }
                    }
                }
                
                // Update and remove expired hover effects
                for (let i = hoveredCells.length - 1; i >= 0; i--) {
                    hoveredCells[i].hoverTime += p.deltaTime / 1000;
                    if (hoveredCells[i].hoverTime > 1.5) {
                        hoveredCells.splice(i, 1);
                    }
                }
            }
            
            function drawHoverEffects() {
                // Draw highlight effects for hovered cells
                for (let i = 0; i < hoveredCells.length; i++) {
                    let cell = hoveredCells[i];
                    
                    // Fade out based on hover time
                    let alpha = p.map(cell.hoverTime, 0, 1.5, 255, 0);
                    
                    // Reverse the color scheme
                    switch (cell.colorScheme) {
                        case 1: // Was black bg, yellow text
                            p.fill('#fff200');
                            p.rect(cell.x, cell.y, cell.w, cell.h);
                            p.fill(0, alpha);
                            break;
                        case 2: // Was yellow bg, black text
                            p.fill(0);
                            p.rect(cell.x, cell.y, cell.w, cell.h);
                            p.fill('#fff200', alpha);
                            break;
                        case 3: // Was white bg, black text
                            p.fill(0);
                            p.rect(cell.x, cell.y, cell.w, cell.h);
                            p.fill(255, alpha);
                            break;
                    }
                    
                    // Draw the word again with new colors
                    p.text(cell.word, cell.x + 2, cell.y + 2);
                }
            }
            
            // Ripple effect when clicking
            p.mousePressed = function() {
                // Create layered ripple effect
                for (let radius = 50; radius <= 150; radius += 25) {
                    setTimeout(function() {
                        for (let i = 0; i < interactiveWords.length; i++) {
                            if (interactiveWords[i].isNear(p.mouseX, p.mouseY, radius) && p.random() < 0.2) {
                                let cell = interactiveWords[i];
                                cell.hovered = true;
                                cell.hoverTime = 0;
                                hoveredCells.push(cell);
                            }
                        }
                    }, (radius - 50) * 10);
                }
                
                return false; // Prevent default
            };
            
            // Resize canvas when window is resized
            p.windowResized = function() {
                p.resizeCanvas(p.windowWidth, p.windowHeight);
                // Adjust cell width based on screen size
                cellW = p.min(80, p.windowWidth / 10);
            };
            
        }, 'p5-canvas');
    </script>
</body>
</html>
