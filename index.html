<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Variable Width Hover Expansion</title>
  <!-- p5.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <script>
    let words = [];   // Will be loaded from CSV
    let wordTable;    // p5.Table object

    // We'll store each word as a "cell" object:
    // {
    //   word: string,
    //   baseW: number,  // measured base width of the text + padding
    //   baseH: number,  // measured base height of the text + padding
    //   x: number,
    //   y: number,
    //   localMult: number, // adjacency scaling
    //   jostleSeedX: number, // random seeds for noise-based jostling
    //   jostleSeedY: number
    // }
    let cells = [];

    // Global scaling factor (mouse wheel)
    let globalScale = 1;

    // Hover expansion multipliers
    // d=0 => 3.0, d=1 => 2.0, d=2 => 1.5, d=3 => 1.25, else => 1.0
    let expansionMap = [3.0, 2.0, 1.5, 1.25];

    // Day (0) or Night (1)
    let mode = 0;

    // For slight jostle motion
    let jostleSpeed = 0.01; // noise speed
    let jostleAmp = 5;      // how many pixels to move

    // Load the CSV in preload()
    function preload() {
      // Make sure "words.csv" is in the same folder
      wordTable = loadTable('words.csv', 'csv', 'header');
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);

      textAlign(LEFT, TOP);
      textSize(12);

      // Build the words array from the CSV
      for (let i = 0; i < wordTable.getRowCount(); i++) {
        words.push(wordTable.getString(i, 'word'));
      }

      // Measure each word’s base size and create a cell object
      for (let i = 0; i < words.length; i++) {
        let wStr = words[i];
        let tw = textWidth(wStr);  
        // Add some padding around the text
        let baseW = tw + 10; 
        let baseH = textAscent() + textDescent() + 6;

        // Create a cell object
        cells.push({
          word: wStr,
          baseW: baseW,
          baseH: baseH,
          x: 0,
          y: 0,
          localMult: 1,
          jostleSeedX: random(1000),
          jostleSeedY: random(1000),
        });
      }
    }

    function draw() {
      // Background depends on mode
      if (mode === 0) {
        background(255); // Day = white
        fill(0);         // black text by default
      } else {
        background(0);   // Night = black
        fill(255);       // white text by default
      }

      // 1) Determine which cell is under the mouse (if any)
      let hoverIndex = findHoverIndex();

      // 2) Assign local scale multipliers based on adjacency
      //    Because this is a single row, adjacency = next/previous indices
      assignLocalMultipliers(hoverIndex);

      // 3) Compute positions left to right, taking into account scaling
      layoutCells();

      // 4) Sort cells by localMult so that the largest (hovered) is drawn last (on top)
      cells.sort((a, b) => a.localMult - b.localMult);

      // 5) Draw cells
      drawCells();
    }

    // Finds which cell is under the mouse. Returns its index, or -1 if none
    function findHoverIndex() {
      // We'll need to do a pass to see if the mouse is inside a cell's bounding box
      // after scaling. Because we push them around, we must do the layout first or do
      // a quick approximate layout. However, for simplicity, we can do a rough pass:
      //  - layout the cells as if localMult=1 for all
      //  - then check bounding boxes with scale
      // But we want the real final positions. So let's do:
      //   1) temporarily set localMult=1 for all
      //   2) layout them
      //   3) check bounding boxes
      //   4) pick the topmost if overlap (i.e. rightmost in the array)
      // This is not perfect if multiple expansions overlap, but let's keep it simpler.

      // Step 1: set localMult=1, layout
      for (let c of cells) {
        c.localMult = 1;
      }
      layoutCells();

      // Step 2: find any cell under the mouse
      let foundIndex = -1;
      for (let i = 0; i < cells.length; i++) {
        let c = cells[i];
        // We'll guess the bounding box by scaled width/height if hovered
        // but we haven't scaled them yet. Let's do an approximate check:
        let w = c.baseW * globalScale;
        let h = c.baseH * globalScale;
        // Add jostle
        let xJ = xJostle(c);
        let yJ = yJostle(c);

        if (
          mouseX >= c.x + xJ &&
          mouseX <= c.x + xJ + w &&
          mouseY >= c.y + yJ &&
          mouseY <= c.y + yJ + h
        ) {
          foundIndex = i;
        }
      }
      return foundIndex;
    }

    // Assign local multipliers based on how far each cell’s index is from the hovered cell
    function assignLocalMultipliers(hoverIndex) {
      if (hoverIndex < 0) {
        // No hover
        for (let c of cells) {
          c.localMult = 1;
        }
        return;
      }

      for (let i = 0; i < cells.length; i++) {
        let dist = abs(i - hoverIndex);
        if (dist < expansionMap.length) {
          cells[i].localMult = expansionMap[dist];
        } else {
          cells[i].localMult = 1.0;
        }
      }
    }

    // Layout cells in a single row, left to right, pushing neighbors so edges touch
    function layoutCells() {
      let xPos = 10;  // start with some left margin
      let yPos = height / 2; // place them vertically centered (roughly)

      for (let i = 0; i < cells.length; i++) {
        let c = cells[i];
        // scaled width
        let sw = c.baseW * globalScale * c.localMult;
        let sh = c.baseH * globalScale * c.localMult;

        c.x = xPos;
        // We keep all at same y
        c.y = yPos - sh / 2; // center them vertically around yPos

        xPos += sw; // move the next cell’s x to the right edge of this one + 0 spacing
      }
    }

    // Draw cells in the sorted order
    function drawCells() {
      // Because we sorted them by localMult ascending, the biggest is last => on top
      for (let c of cells) {
        push();
        translate(c.x + xJostle(c), c.y + yJostle(c));
        scale(c.localMult * globalScale);

        // For day mode, text is black; for night mode, text is white
        // The background is the entire canvas color. 
        // If you want each text to have a box behind it, you can do:
        // fill(mode === 0 ? 255 : 0);
        // rect(0, 0, c.baseW, c.baseH);
        // then set fill(mode === 0 ? 0 : 255) for the text.

        if (c.localMult >= 3) {
          textStyle(BOLD);
        } else {
          textStyle(NORMAL);
        }

        text(c.word, 5, 3); 
        pop();
      }
    }

    // Small jostle offsets using noise
    function xJostle(c) {
      return (noise(c.jostleSeedX + frameCount * jostleSpeed) - 0.5) * jostleAmp;
    }
    function yJostle(c) {
      return (noise(c.jostleSeedY + frameCount * jostleSpeed) - 0.5) * jostleAmp;
    }

    // Toggle day/night on mouse click
    function mousePressed() {
      mode = (mode + 1) % 2;
    }

    // Mouse wheel zoom
    function mouseWheel(event) {
      globalScale = constrain(globalScale - event.delta * 0.001, 0.5, 5);
      return false; // prevent page scroll
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
