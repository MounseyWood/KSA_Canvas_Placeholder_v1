<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive p5.js Text Grid with Stronger Hover Effects</title>
  <!-- p5.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>
<body>
  <script>
    // Array of words for the grid
    let words = [
      "Prada", "Gucci", "YSL", "Dior", "Phoebe Philo", "Roland Mouret", "Phobe English",
      "Paul Smith", "Dunhill", "Community Clothing", "Vivienne Westwood", "Jigsaw", "Toast",
      "H&M", "Hugo Boss", "ZARA", "Tommy Hilfiger", "Timberland", "Lululemon", "Adidas", "Nike",
      "Gymshark", "Reiss", "Kestin", "Oliver Spencer", "Dries van Noten", "Martin Margiela",
      "Donna Karan", "Ralph Lauren", "Calvin Klien", "Armani", "Lacoste", "All Saints", "COS", "ASOS",
      // You can add more words as desired or pull them from an external file.
    ];

    // Base cell dimensions (will be globally scaled)
    let baseCellW = 80;
    let baseCellH = 18;
    let scaleFactor = 1; // Global scale factor (adjustable with the scroll wheel)
    let cellW, cellH;    // Actual cell dimensions computed each frame

    // Noise settings for background effects
    let noiseScale = 0.03;
    let t = 0;

    // Mode: 0 = Day, 1 = Night
    let mode = 0;

    function setup() {
      createCanvas(windowWidth, windowHeight);
      textAlign(LEFT, TOP);
      noStroke();
    }

    function draw() {
      // Update cell dimensions and text size based on the global scale factor
      cellW = baseCellW * scaleFactor;
      cellH = baseCellH * scaleFactor;
      textSize(12 * scaleFactor);
      background(255);

      // Determine which grid cell the mouse is over
      let mouseCol = floor(mouseX / cellW);
      let mouseRow = floor(mouseY / cellH);

      let wordIndex = 0;
      // Loop over grid cells
      for (let y = 0; y < height; y += cellH) {
        for (let x = 0; x < width; x += cellW) {
          // Compute noise based on original position
          let n = noise(x * noiseScale, y * noiseScale, t);

          // Determine grid indices of the current cell
          let col = floor(x / cellW);
          let row = floor(y / cellH);
          // Use Chebyshev distance to the hovered cell
          let d = max(abs(col - mouseCol), abs(row - mouseRow));

          // Determine local scale multiplier based on proximity:
          // d == 0: strongest effect, then diminishing
          let localMult = 1.0;
          if (d === 0) {
            localMult = 3.0;
          } else if (d === 1) {
            localMult = 2.0;
          } else if (d === 2) {
            localMult = 1.5;
          }

          // Save the current transformation state
          push();
          // Translate to the center of the cell
          translate(x + cellW / 2, y + cellH / 2);
          // Apply the local scaling multiplier
          scale(localMult);

          // Choose colors based on mode and noise
          if (mode === 0) {
            // Day mode: default color combinations
            if (n < 0.33) {
              fill(0); // black background
              rect(-cellW/2, -cellH/2, cellW, cellH);
              fill(255, 237, 0); // yellow text
            } else if (n < 0.66) {
              fill(255, 237, 0); // yellow background
              rect(-cellW/2, -cellH/2, cellW, cellH);
              fill(0); // black text
            } else {
              fill(255); // white background
              rect(-cellW/2, -cellH/2, cellW, cellH);
              fill(0); // black text
            }
          } else {
            // Night mode: use blue = rgb(0,146,212)
            if (n < 0.33) {
              fill(255); // white background
              rect(-cellW/2, -cellH/2, cellW, cellH);
              fill(0, 146, 212); // text with new blue shade
            } else if (n < 0.66) {
              fill(0, 146, 212); // blue background
              rect(-cellW/2, -cellH/2, cellW, cellH);
              fill(255); // white text
            } else {
              fill(0); // black background
              rect(-cellW/2, -cellH/2, cellW, cellH);
              fill(255); // white text
            }
          }
          
          // If this cell is directly under the mouse, draw the text in bold
          if (d === 0) {
            textStyle(BOLD);
          } else {
            textStyle(NORMAL);
          }
          // Draw the text with a slight offset relative to the cell's top left
          text(words[wordIndex], -cellW/2 + 2, -cellH/2 + 2);
          wordIndex = (wordIndex + 1) % words.length;
          // Restore transformation
          pop();
        }
      }
      t += 0.005; // Animate noise over time
    }

    // Toggle between day and night mode on mouse click
    function mousePressed() {
      mode = (mode + 1) % 2;
    }

    // Adjust the global scale factor with the mouse wheel
    function mouseWheel(event) {
      // Adjust scaleFactor; constrain between 0.5 and 5
      scaleFactor = constrain(scaleFactor - event.delta * 0.001, 0.5, 5);
      return false; // Prevent default scroll behavior
    }

    // Resize canvas when the window is resized
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
